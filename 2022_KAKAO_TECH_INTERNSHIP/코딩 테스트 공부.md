# 코딩 테스트 공부

## 문제 설명

**[본 문제는 정확성과 효율성 테스트 각각 점수가 있는 문제입니다.]**

당신은 코딩 테스트를 준비하기 위해 공부하려고 합니다. 코딩 테스트 문제를 풀기 위해서는 알고리즘에 대한 지식과 코드를 구현하는 능력이 필요합니다.

알고리즘에 대한 지식은 `알고력`, 코드를 구현하는 능력은 `코딩력`이라고 표현합니다. `알고력`과 `코딩력`은 0 이상의 정수로 표현됩니다.

문제를 풀기 위해서는 문제가 요구하는 일정 이상의 `알고력`과 `코딩력`이 필요합니다.

예를 들어, 당신의 현재 `알고력`이 15, `코딩력`이 10이라고 가정해보겠습니다.

- A라는 문제가 `알고력` 10, `코딩력` 10을 요구한다면 A 문제를 풀 수 있습니다.
- B라는 문제가 `알고력` 10, `코딩력` 20을 요구한다면 `코딩력`이 부족하기 때문에 B 문제를 풀 수 없습니다.

풀 수 없는 문제를 해결하기 위해서는 `알고력`과 `코딩력`을 높여야 합니다. `알고력`과 `코딩력`을 높이기 위한 다음과 같은 방법들이 있습니다.

- `알고력`을 높이기 위해 알고리즘 공부를 합니다. `알고력` 1을 높이기 위해서 1의 시간이 필요합니다.
- `코딩력`을 높이기 위해 코딩 공부를 합니다. `코딩력` 1을 높이기 위해서 1의 시간이 필요합니다.
- 현재 풀 수 있는 문제 중 하나를 풀어 `알고력`과 `코딩력`을 높입니다. 각 문제마다 문제를 풀면 올라가는 알고력과 코딩력이 정해져 있습니다.
- 문제를 하나 푸는 데는 문제가 요구하는 시간이 필요하며 같은 문제를 여러 번 푸는 것이 가능합니다.

당신은 주어진 모든 문제들을 풀 수 있는 `알고력`과 `코딩력`을 얻는 최단시간을 구하려 합니다.

초기의 `알고력`과 `코딩력`을 담은 정수 `alp`와 `cop`, 문제의 정보를 담은 2차원 정수 배열 `problems`가 매개변수로 주어졌을 때, 모든 문제들을 풀 수 있는 `알고력`과 `코딩력`을 얻는 최단시간을 return 하도록 solution 함수를 작성해주세요.

**모든 문제들을 1번 이상씩 풀 필요는 없습니다. `입출력 예 설명`을 참고해주세요.**

------

### 제한사항

- 초기의 `알고력` 을 나타내는 `alp`와 초기의 `코딩력`을 나타내는 `cop`가 입력으로 주어집니다.
  - 0 ≤ `alp`,`cop` ≤ 150

- 1 ≤ `problems`의 길이 ≤ 100

- `problems`의 원소는 [`alp_req`, `cop_req`, `alp_rwd`, `cop_rwd`, `cost`]의 형태로 이루어져 있습니다.

- `alp_req`는 문제를 푸는데 필요한 `알고력`입니다.

  - 0 ≤ `alp_req` ≤ 150

- `cop_req` 는 문제를 푸는데 필요한 `코딩력` 입니다.

  - 0 ≤ `cop_req` ≤ 150

- `alp_rwd`는 문제를 풀었을 때 증가하는 `알고력` 입니다.

  - 0 ≤ `alp_rwd` ≤ 30

- `cop_rwd`  는 문제를 풀었을 때 증가하는 `코딩력` 입니다.

  - 0 ≤ `cop_rwd` ≤ 30

- `cost` 는 문제를 푸는데 드는 시간입니다.

  - 1 ≤ `cost` ≤ 100

**정확성 테스트 케이스 제한사항**

- 0 ≤ `alp`,`cop` ≤ 20

- 1 ≤ `problems` 의 길이 ≤ 6

  - 0 ≤ `alp_req`,`cop_req` ≤ 20
  - 0 ≤ `alp_rwd`,`cop_rwd` ≤ 5
  - 1 ≤ `cost` ≤ 10

**효율성 테스트 케이스 제한사항**

- 주어진 조건 외 추가 제한사항 없습니다.

------

#### 입출력 예

| alp  | cop  | problems                                            | result |
| ---- | ---- | --------------------------------------------------- | ------ |
| 10   | 10   | [[10,15,2,1,2],[20,20,3,3,4]]                       | 15     |
| 0    | 0    | [[0,0,2,1,2],[4,5,3,1,2],[4,11,4,0,2],[10,4,0,4,2]] | 13     |

------

##### 입출력 예 설명

**입출력 예 #1**

1. `코딩력` 5를 늘립니다. `알고력` 10, `코딩력` 15가 되며 시간이 5만큼 소요됩니다.
2. 1번 문제를 5번 풉니다. `알고력` 20, `코딩력` 20이 되며 시간이 10만큼 소요됩니다. 15의 시간을 소요하여 모든 문제를 풀 수 있는 `알고력`과 `코딩력`을 가질 수 있습니다.

**입출력 예 #2**

1. 1번 문제를 2번 풉니다. `알고력` 4, `코딩력` 2가 되며 시간이 4만큼 소요됩니다.
2. `코딩력` 3을 늘립니다. `알고력` 4, `코딩력` 5가 되며 시간이 3만큼 소요됩니다.
3. 2번 문제를 2번 풉니다. `알고력` 10, `코딩력` 7이 되며 시간이 4만큼 소요됩니다.
4. 4번 문제를 1번 풉니다. `알고력` 10, `코딩력` 11이 되며 시간이 2만큼 소요됩니다. 13의 시간을 소요하여 모든 문제를 풀 수 있는 `알고력`과 `코딩력`을 가질 수 있습니다.

------

**제한시간 안내**

- 정확성 테스트 : 10초
- 효율성 테스트 : 언어별로 작성된 정답 코드의 실행 시간의 적정 배수



## 문제 풀이

DFS 방식을 이용해 문제를 해결한다.

`dp`리스트를 생성 각 자리에 최대값 300 or `INF` 값을 설정한다. 모든 문제를 풀기위한 `maxalp`, `maxcop`를 구하고 초기 `alp`, `cop`에서 목표 알고력과 코딩력을 얻는데 필요한 시간을 계산할 수 있다.

`bd_cal` 함수는 인덱스가 최대값을 넘지 않도록 해주는 함수이다.

주의해야 할 점으로 초기 알고력과 코딩력이 최대값보다 클 경우 인덱스 범위를 넘어가는 현상이 벌어지므로 최대값보다 클 경우 초기값을 최대값으로 설정해서 `dfs`에 대입해준다.

```python
def bd_cal(val, axis):
    if axis == "alp":
        return min(maxalp, val)
    else:
        return min(maxcop, val)

def dfs(alp, cop, problems):
    if (maxalp <= alp and maxcop <= cop):
        return 0
    
    if dp[alp][cop] != 300:
        return dp[alp][cop]

    dp[alp][cop] = 301
    dp[alp][cop] = min(dp[alp][cop], 1+ dfs(bd_cal(alp+1,"alp"), cop, problems))
    dp[alp][cop] = min(dp[alp][cop], 1+ dfs(alp, bd_cal(cop+1, "cop"), problems))

    for problem in problems:
        if problem[0] <= alp and problem[1] <= cop:
            dp[alp][cop] = min(dp[alp][cop], problem[4] + dfs(bd_cal(alp + problem[2],"alp"), bd_cal(cop+problem[3],"cop"), problems))

    return dp[alp][cop]


def solution(alp, cop, problems):
    global maxalp, maxcop, dp
    maxalp, maxcop = max([i[0] for i in problems]),  max([i[1] for i in problems])
    dp = [[300 for _ in range(maxcop+1)] for _ in range(maxalp+1)]
    # print(dp)    
    alp = maxalp if alp >= maxalp else alp
    cop = maxcop if cop >= maxcop else cop
    
    return dfs(alp, cop, problems)
```

