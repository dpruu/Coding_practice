# 110 옮기기

## 문제 설명

0과 1로 이루어진 어떤 문자열 x에 대해서, 당신은 다음과 같은 행동을 통해 x를 최대한 사전 순으로 앞에 오도록 만들고자 합니다.

- x에 있는 "110"을 뽑아서, 임의의 위치에 다시 삽입합니다.

예를 들어, x = "11100" 일 때, 여기서 중앙에 있는 "110"을 뽑으면 x = "10" 이 됩니다. 뽑았던 "110"을 x의 맨 앞에 다시 삽입하면 x = "11010" 이 됩니다.

변형시킬 문자열 x가 여러 개 들어있는 문자열 배열 `s`가 주어졌을 때, 각 문자열에 대해서 위의 행동으로 변형해서 만들 수 있는 문자열 중 사전 순으로 가장 앞에 오는 문자열을 배열에 담아 return 하도록 solution 함수를 완성해주세요.

------

### 제한사항

- 1 ≤ `s`의 길이 ≤ 1,000,000
- 1 ≤ `s`의 각 원소 길이 ≤ 1,000,000
- 1 ≤ `s`의 모든 원소의 길이의 합 ≤ 1,000,000

------

#### 입출력 예

| s                                   | result                              |
| ----------------------------------- | ----------------------------------- |
| `["1110","100111100","0111111010"]` | `["1101","100110110","0110110111"]` |

------

##### 입출력 예 설명

**입출력 예 #1**

- 다음 그림은 "1110"을 "1101"로 만드는 과정을 나타낸 것입니다.

![110_ex1.png](https://grepp-programmers.s3.ap-northeast-2.amazonaws.com/files/production/9a8fd58d-71cd-44e9-b9ad-f1f87e653975/110_ex1.png)

- "1101"보다 사전 순으로 더 앞에 오는 문자열을 만들 수 없으므로, 배열에 "1101"을 담아야 합니다.
- 다음 그림은 "100111100"을 "100110110"으로 만드는 과정을 나타낸 것입니다.

![110_ex2.png](https://grepp-programmers.s3.ap-northeast-2.amazonaws.com/files/production/a0c471b7-5bc0-4c0c-914b-f864919fed37/110_ex2.png)

- "100110110"보다 사전 순으로 더 앞에 오는 문자열을 만들 수 없으므로, 배열에 "100110110"을 담아야 합니다.
- 그림에 나온 방식 말고도 다른 방법으로 "100110110"을 만들 수 있습니다.
- 다음 그림은 "0111111010"을 "0110110111"로 만드는 과정을 나타낸 것입니다.

![110_ex3.png](https://grepp-programmers.s3.ap-northeast-2.amazonaws.com/files/production/52534d0b-8883-444e-aa5e-1ca7512a7b7b/110_ex3.png)

- "0110110111"보다 사전 순으로 더 앞에 오는 문자열을 만들 수 없으므로, 배열에 "0110110111"을 담아야 합니다.
- 그림에 나온 방식 말고도 다른 방법으로 "0110110111"을 만들 수 있습니다.

---



## 문제 풀이

반복문을 통해서 `stack`에 문자를 append 한다. 이때 문자가 0이고 `stack`에 '1', '1', '0'일 경우 '110'을 지우고, `cnt`를 증가시킨다. 이 경우 문자열 내의 만들어지는 모든 '110'이 제거되며 그 횟수만큼 `cnt`가 증가한다.

`cnt`가 0일 경우 재배치가 불가능하기 때문에 그대로 문자열을 반환한다.

`cnt`가 0보다 클 경우 문자열이 사전 순으로 앞에 와야하기 때문에 `stack`의 마지막이 0이 나올때까치 출력해 `final`에 추가 0이 나온다면 `break`후 `deque`를 이용해 final의 왼쪽에 '110'을 추가하고 나머지 `stack`의 문자열들을 왼쪽에 추가한다.

```python
from collections import deque

def solution(s):
    answer = []

    for num in s:
        stack = []
        cnt = 0
        for char in num:
            stack.append(char)
            if char == '0' and stack[-3:] == ['1','1','0']:
                del stack[-3:]
                cnt += 1
        
        if cnt == 0:
            answer.append(num)
        else:
            final = deque()
            while stack:
                if stack[-1] == '1':
                    final.append(stack.pop())
                elif stack[-1] == '0':
                    break
            while cnt > 0:
                final.appendleft('110')            
                cnt -= 1
            while stack:
                final.appendleft(stack.pop())
            
            answer.append(''.join(final))
    
    return answer
