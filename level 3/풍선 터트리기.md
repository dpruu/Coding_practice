# 풍선 터트리기

## 문제 설명

일렬로 나열된 n개의 풍선이 있습니다. 모든 풍선에는 서로 다른 숫자가 써져 있습니다. 당신은 다음 과정을 반복하면서 풍선들을 단 1개만 남을 때까지 계속 터트리려고 합니다.

1. 임의의 **인접한** 두 풍선을 고른 뒤, 두 풍선 중 하나를 터트립니다.
2. 터진 풍선으로 인해 풍선들 사이에 빈 공간이 생겼다면, 빈 공간이 없도록 풍선들을 중앙으로 밀착시킵니다.

여기서 조건이 있습니다. 인접한 두 풍선 중에서 **번호가 더 작은 풍선**을 터트리는 행위는 최대 1번만 할 수 있습니다. 즉, 어떤 시점에서 인접한 두 풍선 중 번호가 더 작은 풍선을 터트렸다면, 그 이후에는 인접한 두 풍선을 고른 뒤 번호가 더 큰 풍선만을 터트릴 수 있습니다.

당신은 어떤 풍선이 최후까지 남을 수 있는지 알아보고 싶습니다. 위에 서술된 조건대로 풍선을 터트리다 보면, 어떤 풍선은 최후까지 남을 수도 있지만, 어떤 풍선은 무슨 수를 쓰더라도 마지막까지 남기는 것이 **불가능**할 수도 있습니다.

일렬로 나열된 풍선들의 번호가 담긴 배열 a가 주어집니다. 위에 서술된 규칙대로 풍선들을 1개만 남을 때까지 터트렸을 때 최후까지 남기는 것이 가능한 풍선들의 개수를 return 하도록 solution 함수를 완성해주세요.

------

### 제한 사항

- a의 길이는 1 이상 1,000,000 이하입니다.
  - `a[i]`는 i+1 번째 풍선에 써진 숫자를 의미합니다.
  - a의 모든 수는 -1,000,000,000 이상 1,000,000,000 이하인 정수입니다.
  - a의 모든 수는 서로 다릅니다.

------

#### 입출력 예

| a                                       | result |
| --------------------------------------- | ------ |
| `[9,-1,-5]`                             | 3      |
| `[-16,27,65,-2,58,-92,-71,-68,-61,-33]` | 6      |

------

##### 입출력 예 설명

입출력 예 #1

- 첫 번째 풍선(9가 써진 풍선)을 최후까지 남기는 방법은 다음과 같습니다.
  1. `[9, -1, -5]` 에서 -1, -5가 써진 풍선을 고른 뒤, -1이 써진 풍선(번호가 더 큰 것)을 터트립니다.
  2. `[9, -5]` 에서 9, -5가 써진 풍선을 고른 뒤, -5가 써진 풍선(번호가 더 작은 것)을 터트립니다.
- 두 번째 풍선(-1이 써진 풍선)을 최후까지 남기는 방법은 다음과 같습니다.
  1. `[9, -1, -5]` 에서 9, -1이 써진 풍선을 고른 뒤, 9가 써진 풍선(번호가 더 큰 것)을 터트립니다.
  2. `[-1, -5]` 에서 -1, -5가 써진 풍선을 고른 뒤, -5가 써진 풍선(번호가 더 작은 것)을 터트립니다.
- 세 번째 풍선(-5가 써진 풍선)을 최후까지 남기는 방법은 다음과 같습니다.
  1. `[9, -1, -5]` 에서 9, -1이 써진 풍선을 고른 뒤, 9가 써진 풍선(번호가 더 큰 것)을 터트립니다.
  2. `[-1, -5]` 에서 -1, -5가 써진 풍선을 고른 뒤, -1이 써진 풍선(번호가 더 큰 것)을 터트립니다.
- 3개의 풍선이 최후까지 남을 수 있으므로, 3을 return 해야 합니다.

입출력 예 #2

- 최후까지 남을 수 있는 풍선은 -16, -92, -71, -68, -61, -33이 써진 풍선으로 모두 6개입니다.

---



## 문제 풀이

번호가 작은 풍선이 터지며, 단 한 번만 큰 번호의 풍선이 터질 수 있다. 이 말은 기준이 되는 풍선 양옆으로 적어도 한 방향에서는 기준 풍선보다 작은 번호가 있어서는 안 된다. 

기준 풍선을 정하고 양쪽 방향 중 한 방향이라도 가장 작은 번호가 기준 풍선일 경우 `answer `에 1을 더하는 것으로 답을 구했다.

```python
def solution(a):
   answer = 0
   for i in range(len(a)):
     left, right = a[0:i+1], a[i:]
     if min(left) == a[i] or min(right) == a[i]:
       answer += 1
    
   return answer
```

그러나 이 경우 실행 시간이 너무 길어 테스트를 통과할 수 없게된다. 리스트의 길이가 길 경우 리스트를 나누고 비교할 때 시간이 많이 소요된다고 판단했다.

```python
def solution(a):
    left_list,right_list = [], []
    left_v, right_v =  float("inf") , float("inf") 

    for i in range(len(a)):
        if a[i] < left_v:
            left_v = a[i]
            left_list.append(a[i])
        if a[-1-i] < right_v:
            right_v = a[-1-i]
            right_list.append(a[-1-i])
        
    return len(set(left_list)|set(right_list))
```

`left_list`는 왼쪽에서부터 가장 작은 번호를 저장, `right_list`에는 오른쪽에서부터 가장 작은 값을 저장한다. 이때 번호가 갱신될 때마다 list에 해당 번호를 저장한다. 최종적으로는 두 리스트에 최후까지 남을 수 있는 풍선의 번호들이 저장되고 `set`의 합집합 연산을 통해 최종 결과를 리턴한다. 모든 번호는 한 번씩만 등장하기 때문에 `set`연산으로도 아무 문제 없다.

