# 쿼드압축 후 개수 세기

###### 문제 설명

0과 1로 이루어진 2n x 2n 크기의 2차원 정수 배열 arr이 있습니다. 당신은 이 arr을 [쿼드 트리](https://en.wikipedia.org/wiki/Quadtree)와 같은 방식으로 압축하고자 합니다. 구체적인 방식은 다음과 같습니다.

1. 당신이 압축하고자 하는 특정 영역을 S라고 정의합니다.
2. 만약 S 내부에 있는 모든 수가 같은 값이라면, S를 해당 수 하나로 압축시킵니다.
3. 그렇지 않다면, S를 정확히 4개의 균일한 정사각형 영역(입출력 예를 참고해주시기 바랍니다.)으로 쪼갠 뒤, 각 정사각형 영역에 대해 같은 방식의 압축을 시도합니다.

arr이 매개변수로 주어집니다. 위와 같은 방식으로 arr을 압축했을 때, 배열에 최종적으로 남는 0의 개수와 1의 개수를 배열에 담아서 return 하도록 solution 함수를 완성해주세요.

------

##### 제한사항

- arr의 행의 개수는 1 이상 1024 이하이며, 2의 거듭 제곱수 형태를 하고 있습니다. 즉, arr의 행의 개수는 1, 2, 4, 8, ..., 1024 중 하나입니다.
  - arr의 각 행의 길이는 arr의 행의 개수와 같습니다. 즉, arr은 정사각형 배열입니다.
  - arr의 각 행에 있는 모든 값은 0 또는 1 입니다.

------

##### 입출력 예

| arr                                                          | result    |
| ------------------------------------------------------------ | --------- |
| `[[1,1,0,0],[1,0,0,0],[1,0,0,1],[1,1,1,1]]`                  | `[4,9]`   |
| `[[1,1,1,1,1,1,1,1],[0,1,1,1,1,1,1,1],[0,0,0,0,1,1,1,1],[0,1,0,0,1,1,1,1],[0,0,0,0,0,0,1,1],[0,0,0,0,0,0,0,1],[0,0,0,0,1,0,0,1],[0,0,0,0,1,1,1,1]]` | `[10,15]` |



### 문제 풀이

재귀 함수를 이용해 길이가 1인 사각형으로 부터 길이를 늘려가며 압축하는 과정을 통해 결과를 도출한다.

1. 행렬 `arr`의 좌표 값마다 0일 때는 [1,0], 1일 때는 [0,1]로 리턴한다.
2. 행렬 `arr`을 4등분해서 탐색할 수 있도록 행렬의 길이 `len(arr)`을 변수로 두고 2로 나눠서 x,y 좌표에 더해가며 4가지 영역을 탐색하도록 한다.
3. 각 영역은 길이가 1인 사각형 영역이 나올때까지 `Quad` 함수가 반복된다.
4. 길이가 1인 영역이 나오면 a,b,c,d_quad의 값들을 비교 모든 값이 같다면 그 상위 Quad함수 값은 같은 값((1,0) or (0,1))로 출력되고, 그렇지 않다면 `map`을 이용해 각각 더해져 (n,m) 값으로 나오게 된다.
5. 예시 1의 경우 `Quad(0, 0, 4, arr)`로 시작해서 
   `Quad(0, 0, 2, arr), Quad(0, 2, 2, arr), Quad(2, 0, 2, arr), Quad(2, 2, 2, arr)`로 나뉘고 각각 4개의 영역으로 다시 나뉘어진다. <u>a영역의 경우 (1,3)</u>이 <u>b 영역의 경우 모두 0이므로 (1,0)</u>, c와 d 영역은 a와 마찬가지로 (1,3)이 나오고 `Quad(0, 0, 4, arr)`은 이 4개의 영역의 값이 다 같지 않으므로 더해
   (1,3) + (1,0) + (1,3) + (1,3) = (4,9)가 출력되게 되는 것이다.

```python
def Quad(x, y, n, arr):
    if n == 1:
        if arr[x][y] == 1:
            return [0, 1] 
        else:
            return [1, 0]
    
    a_quad = Quad(x, y , n // 2, arr)
    b_quad = Quad(x, y + n // 2, n // 2, arr)
    c_quad = Quad(x + n // 2, y, n // 2, arr)
    d_quad = Quad(x + n // 2, y + n // 2, n // 2, arr)
    
    if a_quad == b_quad == c_quad == d_quad == [0, 1] or a_quad == b_quad == c_quad == d_quad == [1, 0]:
        return a_quad
    else:
        return list(map(sum, zip(a_quad, b_quad, c_quad, d_quad)))


def solution(arr):
    answer = Quad(0, 0, len(arr), arr)
    
    return answer
```

