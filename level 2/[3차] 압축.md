# 압축

신입사원 어피치는 카카오톡으로 전송되는 메시지를 압축하여 전송 효율을 높이는 업무를 맡게 되었다. 메시지를 압축하더라도 전달되는 정보가 바뀌어서는 안 되므로, 압축 전의 정보를 완벽하게 복원 가능한 무손실 압축 알고리즘을 구현하기로 했다.

어피치는 여러 압축 알고리즘 중에서 성능이 좋고 구현이 간단한 **LZW**(Lempel–Ziv–Welch) 압축을 구현하기로 했다. LZW 압축은 1983년 발표된 알고리즘으로, 이미지 파일 포맷인 GIF 등 다양한 응용에서 사용되었다.

LZW 압축은 다음 과정을 거친다.

1. 길이가 1인 모든 단어를 포함하도록 사전을 초기화한다.
2. 사전에서 현재 입력과 일치하는 가장 긴 문자열 `w`를 찾는다.
3. `w`에 해당하는 사전의 색인 번호를 출력하고, 입력에서 `w`를 제거한다.
4. 입력에서 처리되지 않은 다음 글자가 남아있다면(`c`), `w+c`에 해당하는 단어를 사전에 등록한다.
5. 단계 2로 돌아간다.

압축 알고리즘이 영문 대문자만 처리한다고 할 때, 사전은 다음과 같이 초기화된다. 사전의 색인 번호는 정수값으로 주어지며, 1부터 시작한다고 하자.

| 색인 번호 | 1    | 2    | 3    | ...  | 24   | 25   | 26   |
| --------- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| 단어      | A    | B    | C    | ...  | X    | Y    | Z    |

예를 들어 입력으로 `KAKAO`가 들어온다고 하자.

1. 현재 사전에는 `KAKAO`의 첫 글자 `K`는 등록되어 있으나, 두 번째 글자까지인 `KA`는 없으므로, 첫 글자 `K`에 해당하는 색인 번호 11을 출력하고, 다음 글자인 `A`를 포함한 `KA`를 사전에 27 번째로 등록한다.
2. 두 번째 글자 `A`는 사전에 있으나, 세 번째 글자까지인 `AK`는 사전에 없으므로, `A`의 색인 번호 1을 출력하고, `AK`를 사전에 28 번째로 등록한다.
3. 세 번째 글자에서 시작하는 `KA`가 사전에 있으므로, `KA`에 해당하는 색인 번호 27을 출력하고, 다음 글자 `O`를 포함한 `KAO`를 29 번째로 등록한다.
4. 마지막으로 처리되지 않은 글자 `O`에 해당하는 색인 번호 15를 출력한다.

| 현재 입력(w) | 다음 글자(c) | 출력 | 사전 추가(w+c) |
| ------------ | ------------ | ---- | -------------- |
| K            | A            | 11   | 27: KA         |
| A            | K            | 1    | 28: AK         |
| KA           | O            | 27   | 29: KAO        |
| O            |              | 15   |                |

이 과정을 거쳐 다섯 글자의 문장 `KAKAO`가 4개의 색인 번호 [11, 1, 27, 15]로 압축된다.



### 입력 형식

입력으로 영문 대문자로만 이뤄진 문자열 `msg`가 주어진다. `msg`의 길이는 1 글자 이상, 1000 글자 이하이다.



### 출력 형식

주어진 문자열을 압축한 후의 사전 색인 번호를 배열로 출력하라.



### 문제 풀이

1. `chr(65) = A` 이므로 반복문을 이용해 딕셔너리를 생성한다.
2. `KAKAO`를 예시로 `while`반복을 진행, `msg` 문장 전부를 딕셔너리 `key`값에 있는지 확인 후 없을 경우 끝에서부터 한 글자씩 제거하면서 `key`에 포함되는지 확인한다. 예시의 경우 처음으로 `key`에 포함되는 단어는 `k`로, `k`의 색인 번호를 `answer`에 추가 후  `msg` 배열에서 `k` 다음 글자를 포함하는 단어를 사전에 추가후 딕셔너리 최대 값에 1을 더해 사전에 추가한다. 이번 경우 `ka = 27` 로 저장된다.
3. `k`에 해당하는 색인 번호가 `answer`에 추가됬기 때문에 `index`을 1 증가해 다음 `akao`부터  `a`까지 `key`값에 포함되는지 확인하고 색인 번호를 출력 후 다음 문자를 더해 `key`에 추가한다. 
   이때 `index`를 증가할 때 확인되는 값의 길이 만큼 넘겨줘야 하기 때문에 `len(w_input)`만큼 `index`를 증가시켜야한다.
4. 해당 과정을 반복하면 마지막으로는`w_input`는  `o`가 출력되고 이때 `end` 값은 초기값과 같기 때문에 `answer` 가 `return`된다.

```python
def solution(msg):
    di = dict()
    for i in range(65,91):
        di[chr(i)] = i - 64
    index = 0
    answer = []
    end = len(msg)
    
    while True:
        w_input = msg[index:end]
        if w_input in di.keys():
            answer.append(di[w_input])
            if end >= len(msg):
                return answer
            di[w_input+msg[end]] = max(di.values())+1
            index += len(w_input)
            end = len(msg)                
        else:
            end -= 1
```