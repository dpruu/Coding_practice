# 2개 이하로 다른 비트

### 문제 설명

양의 정수 `x`에 대한 함수 `f(x)`를 다음과 같이 정의합니다.

- `x`보다 크고 `x`와 **비트가 1~2개 다른** 수들 중에서 제일 작은 수

예를 들어,

- `f(2) = 3` 입니다. 다음 표와 같이 2보다 큰 수들 중에서 비트가 다른 지점이 2개 이하이면서 제일 작은 수가 3이기 때문입니다.

| 수   | 비트         | 다른 비트의 개수 |
| ---- | ------------ | ---------------- |
| 2    | `000...0010` |                  |
| 3    | `000...0011` | 1                |

- `f(7) = 11` 입니다. 다음 표와 같이 7보다 큰 수들 중에서 비트가 다른 지점이 2개 이하이면서 제일 작은 수가 11이기 때문입니다.

| 수   | 비트         | 다른 비트의 개수 |
| ---- | ------------ | ---------------- |
| 7    | `000...0111` |                  |
| 8    | `000...1000` | 4                |
| 9    | `000...1001` | 3                |
| 10   | `000...1010` | 3                |
| 11   | `000...1011` | 2                |

정수들이 담긴 배열 `numbers`가 매개변수로 주어집니다. `numbers`의 모든 수들에 대하여 각 수의 `f` 값을 배열에 차례대로 담아 return 하도록 solution 함수를 완성해주세요.

------

### 제한사항

- 1 ≤ `numbers`의 길이 ≤ 100,000
- 0 ≤ `numbers`의 모든 수 ≤ 10**15

### 문제 풀이

1. x를 이진법으로 변환한다. x보다 큰 값들 중 비트가 추가되는 경우를 고려해 맨 앞비트에 `0`을 더한다.
2. `.rfind()`를 이용해서 가장 오른쪽 `0`의 위치를 확인한다. 짝수일 경우 이진법이기 때문에 오른쪽 끝자리가 0이므로 가장 오른쪽 비트에 1을 더한 값이 비트가 2개 이하로 다른 수이다.
3. 홀수일 경우 마지막 `0`의 위치 다음 인덱스를 `0`으로 변환해야 증가한 값중 다른 비트의 개수가 최소가 되는 경우이다.    

```python
def solution(numbers):
    answer = []

    for number in numbers:
        bin_number = list('0' + bin(number)[2:])
        idx = ''.join(bin_number).rfind('0')
        bin_number[idx] = '1'
        
        if number % 2 == 1:
            bin_number[idx+1] = '0'
        
        answer.append(int(''.join(bin_number), 2))

    return answer
```