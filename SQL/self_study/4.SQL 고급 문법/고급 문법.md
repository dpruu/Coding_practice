# 고급 문법

## 1. MySQL 데이터 형식

### 1. 데이터 형식

#### 1) 정수형

| 데이터 형식 | 바이트 수 |     숫자 범위      |
| :---------: | :-------: | :----------------: |
|   TINYINT   |     1     |     -128 ~ 127     |
|  SMALLINT   |     2     |  -32,768 ~ 32,767  |
|     INT     |     4     |  약 -21억 ~ +21억  |
|   BIGINT    |     8     | 약 -900경 ~ +900경 |

- `TINYINT`와 같은 데이터 형식의 경우 -128 ~ 127로 범위가 부족할 수 있다. 그렇기 때문에 `TINYINT UNSIGNED`를 이용해 0 ~ 255 까지 표현이 가능해진다.

#### 2) 문자형

|  데이터 형식  | 바이트 수 |
| :-----------: | :-------: |
|  CHAR(개수)   |  1 ~ 255  |
| VARCHAR(개수) | 1 ~ 16383 |

- `CHAR`는 자릿수가 고정되어있다.
- `VARCHAR`은 가변길이 문자형으로 CHAR(10), VARCHAR(10)에 각각 '가나다'를 저장할 경우 `CHAR`은 7자리를 낭비, `VARCHAR`은 3자리만 사용한다.
  - 모두 같은 글자의 입력이 들어올 경우 `CHAR`은 사용하는 것이 경제적이지만, 글자 개수가 고정이지 않을 경우 `VARCHAR`을 사용하는 것이 좋다.
- 전화번호와 같이 숫자로서 의미가 없는 문자는 문자형으로 저장한다.
  - 더하기/빼기 등의 연산에 의미
  - 크다/작다 또는 순서의 의미

#### 3) 대량의 데이터 형식

```SQL
CREATE TABLE big_table (
	data1 CHAR(256)
	data2 VARCHAR(16384) );
```

![image-20211230142720711](markdown-images/image-20211230142720711.png)

> `VARCHAR`는 최대 16383자까지 지정이 가능하지만 열의 길이를 너무 크게 설정했다는 오류가 발생한다. 더큰 데이터를 저장하기 위한 데이터 형식이 존재한다.

|      | 데이터 형식 |   바이트 수    |
| :--: | :---------: | :------------: |
| TEXT |    TEXT     |   1 ~ 65535    |
|      |  LONGTEXT   | 1 ~ 4294967295 |
| BLOB |    BLOB     |   1 ~ 65535    |
|      |  LONGBLOB   | 1 ~ 4294967295 |

- `TEXT`로 지정하면 65535자까지, `LONGTEXT`로 지정하면 약 42억자까지 저장된다. 소설이나 영화 대본과 같은 내용을 저장한다면 필요한 데이터 형식
- `BLOB`는 Binary Long Object의 약자로 글자가 아닌 이미지, 동영상 등의 데이터

```SQL
CREATE DATABASE netflix_db;
USE netflix_db;
CREATE TABLE movie
	(movie_id INT,
     movie_title VARCHAR(30),
     movie_director VARCHAR(20),
     movie_star VARCHAR(20),
     movie_script LONGTEXT,
     movie_film LONGBLOB
    )
```

#### 4) 실수형

| 데이터 형식 | 바이트 수 | 설명                        |
| ----------- | --------- | --------------------------- |
| FLOAT       | 4         | 소수점 아래 7자리까지 표현  |
| DOUBLE      | 8         | 소수점 아래 15자리까지 표현 |

#### 5) 날짜형

- `DATE`는 날짜만, `TIME`은 시간만, `DATETIME`은 둘 다 저장.

| 데이터 형식 | 바이트 수 | 설명                                                   |
| :---------: | :-------: | ------------------------------------------------------ |
|    DATE     |     3     | 날짜만 저장. YYYY-MM-DD 형식으로 사용                  |
|    TIME     |     3     | 시간만 저장. HH:MM:SS 형식으로 사용                    |
|  DATETIME   |     8     | 날짜 및 시간을 저장. YYYY-MM-DD HH:MM:SS 형식으로 사용 |

### 2. 변수의 사용

- 기본 형식

```SQL
SET @변수이름 = 변수의 값;
SELECT @변수이름 ;
```

- 예시

```SQL
USE market_db;
SET @myVar1 = 5;
SET @myVar2 = 4.25;

SELECT @myVar1 ;
SELECT @myVar1 + @myVar2 ;

SET @txt = '가수 이름 ==> ';
SET @height = 166;
SELECT @txt, mem_name FROM member WHERE height > @height;
```

![image-20211231140231777](markdown-images/image-20211231140231777.png)

- `LIMIT`에는 변수를 사용할 수 없다
  - 이를 해결하기 위해 `PREPARE`, `EXECUTE`를 사용한다.

```SQL
SET @count = 3;
PREPARE mySQL FROM 'SELECT mem_name, height FROM member ORDER BY height LIMIT ?';
EXECUTE mySQL USING @count;
```

![image-20211231141304098](markdown-images/image-20211231141304098.png)

### 3. 데이터 형 변환

> 직접 함수를 사용해 변환하는 명시적인 변환
>
> 별도의 지시 없이 자연스럽게 변환되는 암시적인 변환

#### 1) 명시적인 변환

- 기본 형식

```SQL
CAST (값 AS 데이터_형식 [(길이)])
CONVERT (값, 데이터_형식 [(길이)])
```

```SQL
SELECT AVG(price) AS '평균 가격' FROM buy;
# 142.9167
```

```SQL
SELECT AVG(price) AS '평균 가격' FROM buy;
# OR
SELECT CONVERT(AVG(price) , SIGNED) '평균 가격' FROM buy;
# 143
```

- `CAST()`함수는 정수를 문자로 변환이 가능하다.
  - `CONCAT()`함수를 이용해 문자를 이어줄 수 있다.


```SQL
SELECT num, CONCAT(CAST(price AS CHAR), 'X', CAST(amount AS CHAR), '=' )
	   '가격X수량', price*amount '구매액'
FROM buy;
```

![image-20211231142323040](markdown-images/image-20211231142323040.png)

#### 2) 암시적인 변환

```SQL
SELECT '100' + '200'; # 300
SELECT CONCAT('100','200'); # 100200
SELECT CONCAT(100,'200'); # 100200
SELECT 100+'200'; # 300
```



## 2. 두 테이블을 묶는 조인

### 1. 내부 조인

- 기본 형식

```SQL 
SELECT <열 목록>
FROM <첫 번째 테이블>
	INNER JOIN <두 번째 테이블>
	ON <조인될 조건>
[WHERE 검색 조건]
```

```SQL
USE market_db;
SELECT * 
	FROM buy
    INNER JOIN member
    ON buy.mem_id = member.mem_id
where buy.mem_id = 'GRL';
```

![image-20211231144335572](markdown-images/image-20211231144335572.png)

- `where buy.mem_id = 'GRL';` 생략 시

![image-20211231144440128](markdown-images/image-20211231144440128.png)

- 내부 조인의 간결한 표현
  - `mem_id`를 사용할 경우 회원, 구매 테이블에 모두 있어 오류 발생한다.

```SQL
SELECT buy.mem_id, mem_name, prod_name, addr, CONCAT(phone1, phone2) '연락처'
	FROM buy
		INNER JOIN member
		ON buy.mem_id = member.mem_id;
```

![image-20211231144933602](markdown-images/image-20211231144933602.png)

- 코드가 너무 길어져 복잡해 보이기 때문에 테이블 이름에 별칭을 붙일 수 있다.

```SQL
SELECT B.mem_id, M.mem_name, B.prod_name, M.addr, CONCAT(M.phone1, M.phone2) '연락처'
	FROM buy B
		INNER JOIN member M
		ON B.mem_id = M.mem_id;
```

- 내부 조인의 활용

```SQL
SELECT B.mem_id, M.mem_name, B.prod_name, M.addr
	FROM buy B
		INNER JOIN member M
		ON B.mem_id = M.mem_id
	ORDER BY M.mem_id;
```

![image-20211231145415540](markdown-images/image-20211231145415540.png)

#### ※ 중복된 결과 1개만 출력

```SQL
SELECT DISTINCT M.mem_id, M.mem_name, M.addr
	FROM buy B
		INNER JOIN member M
		ON B.mem_id = M.mem_id
	ORDER BY M.mem_id;
```

![image-20211231145540175](markdown-images/image-20211231145540175.png)

### 2. 외부 조인

> 필요한 내용이 한쪽 테이블에만 있어도 결과를 추출할 수 있다.

- 기본 형식

```SQL
SELECT <열 목록>
FROM <첫 번째 테이블(LEFT 테이블)>
	<LEFT|RIGHT|FULL> OUTER JOIN <두 번째 테이블(RIGHT 테이블)>
	ON <조인될 조건>
[WHERE 검색 조건];
```

- 예시

```SQL
SELECT M.mem_id, M.mem_name, B.prod_name, M.addr
	FROM member M
		LEFT OUTER JOIN buy B
		ON M.mem_id = B.mem_id
	ORDER BY M.mem_id;
```

```SQL
SELECT M.mem_id, M.mem_name, B.prod_name, M.addr
	FROM buy B
		RIGHT OUTER JOIN member M
		ON M.mem_id = B.mem_id
	ORDER BY M.mem_id;
```

![image-20211231150119336](markdown-images/image-20211231150119336.png)

- 외부 조인의 활용
  - 구매 기록이 없는 회원 목록

```SQL
SELECT DISTINCT M.mem_id,B.prod_name, M.mem_name, M.addr
	FROM member M
		LEFT OUTER JOIN buy B
		ON M.mem_id = B.mem_id
	WHERE B.prod_name IS NULL
	ORDER BY M.mem_id;
```

![image-20211231150527532](markdown-images/image-20211231150527532.png)

### 3. 기타 조인

#### 1) 상호 조인

> 한쪽 테이블의 모든 행과 다른 쪽 모든 행을 조인시키는 기능을 말한다. 상호 조인 결과의 전체 행의 개수는 두 테이블의 각 행의 개수를 곱한 개수가 된다.

- 특징
  - ON 구문을 사용할 수 없다.
  - 결과의 내용은 의미가 없다. 랜덤으로 조인하기 때문.
  - 상호 조인의 주 용도는 테스트하기 위해 대용량의 데이터를 생성할 때.

```SQL
SELECT * 
	FROM buy
		CROSS JOIN member;
```

![image-20211231150855148](markdown-images/image-20211231150855148.png)

- 대용량의 테이블을 만들고 싶을 경우 `CREATE TABLE ~ SELECT`문을 사용

```SQL
CREATE TABLE cross_table
	SELECT * 
		FROM sakila.actor
			CROSS JOIN world.county;
SELECT * FROM cross_table LIMIT 5;
```

#### 2) 자체 조인

> 자신이 자신과 조인하는 의미. 대표적인 사례로 회사의 조직 관계를 살펴볼 수 있다.

- 기본 형식

```SQL
SELECT <열 목록>
FROM <테이블> 별칭A
	INNER JOIN <테이블> 별칭 B
	ON <조인될 조건>
[WHERE 검색 조건]
```

```SQL
SELECT A.emp "직원", B.emp "직속상관", B.phone "직속상관연락처"
	FROM emp_table A
		INNER JOIN emp_table B
        ON A.manager = B.emp
	WHERE A.emp = '경리부장';
```

![image-20211231151737839](markdown-images/image-20211231151737839.png)

## 3. SQL 프로그래밍

